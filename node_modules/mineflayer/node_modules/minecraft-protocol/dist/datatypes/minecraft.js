'use strict';

var nbt = require('prismarine-nbt');
var UUID = require('uuid-1345');
var zlib = require('zlib');

module.exports = {
  'UUID': [readUUID, writeUUID, 16],
  'nbt': [readNbt, writeNbt, sizeOfNbt],
  'optionalNbt': [readOptionalNbt, writeOptionalNbt, sizeOfOptionalNbt],
  'compressedNbt': [readCompressedNbt, writeCompressedNbt, sizeOfCompressedNbt],
  'restBuffer': [readRestBuffer, writeRestBuffer, sizeOfRestBuffer],
  'entityMetadataLoop': [readEntityMetadata, writeEntityMetadata, sizeOfEntityMetadata]
};
var PartialReadError = require('protodef').utils.PartialReadError;

function readUUID(buffer, offset) {
  if (offset + 16 > buffer.length) throw new PartialReadError();
  return {
    value: UUID.stringify(buffer.slice(offset, 16 + offset)),
    size: 16
  };
}

function writeUUID(value, buffer, offset) {
  var buf = UUID.parse(value);
  buf.copy(buffer, offset);
  return offset + 16;
}

function readNbt(buffer, offset) {
  return nbt.proto.read(buffer, offset, "nbt");
}

function writeNbt(value, buffer, offset) {
  return nbt.proto.write(value, buffer, offset, "nbt");
}

function sizeOfNbt(value) {
  return nbt.proto.sizeOf(value, "nbt");
}

function readOptionalNbt(buffer, offset) {
  if (offset + 1 > buffer.length) throw new PartialReadError();
  if (buffer.readInt8(offset) == 0) return { size: 1 };
  return nbt.proto.read(buffer, offset, "nbt");
}

function writeOptionalNbt(value, buffer, offset) {
  if (value == undefined) {
    buffer.writeInt8(0, offset);
    return offset + 1;
  }
  return nbt.proto.write(value, buffer, offset, "nbt");
}

function sizeOfOptionalNbt(value) {
  if (value == undefined) return 1;
  return nbt.proto.sizeOf(value, "nbt");
}

// Length-prefixed compressed NBT, see differences: http://wiki.vg/index.php?title=Slot_Data&diff=6056&oldid=4753
function readCompressedNbt(buffer, offset) {
  if (offset + 2 > buffer.length) throw new PartialReadError();
  var length = buffer.readInt16BE(offset);
  if (length == -1) return { size: 2 };
  if (offset + 2 + length > buffer.length) throw new PartialReadError();

  var compressedNbt = buffer.slice(offset + 2, offset + 2 + length);

  var nbtBuffer = zlib.gunzipSync(compressedNbt); // TODO: async

  var results = nbt.proto.read(nbtBuffer, 0, "nbt");
  return {
    size: length + 2,
    value: results.value
  };
}

function writeCompressedNbt(value, buffer, offset) {
  if (value == undefined) {
    buffer.writeInt16BE(-1, offset);
    return offset + 2;
  }
  var nbtBuffer = new Buffer(sizeOfNbt(value));
  nbt.proto.write(value, nbtBuffer, 0, "nbt");

  var compressedNbt = zlib.gzipSync(nbtBuffer); // TODO: async
  compressedNbt.writeUInt8(0, 9); // clear the OS field to match MC

  buffer.writeInt16BE(compressedNbt.length, offset);
  compressedNbt.copy(buffer, offset + 2);
  return offset + 2 + compressedNbt.length;
}

function sizeOfCompressedNbt(value) {
  if (value == undefined) return 2;

  var nbtBuffer = new Buffer(sizeOfNbt(value, "nbt"));
  nbt.proto.write(value, nbtBuffer, 0, "nbt");

  var compressedNbt = zlib.gzipSync(nbtBuffer); // TODO: async

  return 2 + compressedNbt.length;
}

function readRestBuffer(buffer, offset) {
  return {
    value: buffer.slice(offset),
    size: buffer.length - offset
  };
}

function writeRestBuffer(value, buffer, offset) {
  value.copy(buffer, offset);
  return offset + value.length;
}

function sizeOfRestBuffer(value) {
  return value.length;
}

function readEntityMetadata(buffer, offset, _ref) {
  var type = _ref.type;
  var endVal = _ref.endVal;

  var cursor = offset;
  var metadata = [];
  var item = void 0;
  while (true) {
    if (offset + 1 > buffer.length) throw new PartialReadError();
    item = buffer.readUInt8(cursor);
    if (item === endVal) {
      return {
        value: metadata,
        size: cursor + 1 - offset
      };
    }
    var results = this.read(buffer, cursor, type, {});
    metadata.push(results.value);
    cursor += results.size;
  }
}

function writeEntityMetadata(value, buffer, offset, _ref2) {
  var type = _ref2.type;
  var endVal = _ref2.endVal;

  var self = this;
  value.forEach(function (item) {
    offset = self.write(item, buffer, offset, type, {});
  });
  buffer.writeUInt8(endVal, offset);
  return offset + 1;
}

function sizeOfEntityMetadata(value, _ref3) {
  var type = _ref3.type;

  var size = 1;
  for (var i = 0; i < value.length; ++i) {
    size += this.sizeOf(value[i], type, {});
  }
  return size;
}
//# sourceMappingURL=../maps/datatypes/minecraft.js.map
