{"version":3,"sources":["client/encrypt.js"],"names":[],"mappings":"AAAA;;AAEA,IAAM,SAAS,QAAQ,QAAR,CAAf;AACA,IAAM,YAAY,QAAQ,WAAR,EAAqB,MAArB,CAA4B,EAA5B,CAAlB;AACA,IAAM,OAAK,QAAQ,SAAR,CAAX;AACA,IAAM,QAAQ,QAAQ,OAAR,EAAiB,oBAAjB,CAAd;;AAEA,OAAO,OAAP,GAAiB,UAAS,MAAT,EAAiB,OAAjB,EAA0B;AACzC,SAAO,IAAP,CAAY,kBAAZ,EAAgC,sBAAhC;;AAEA,WAAS,sBAAT,CAAgC,MAAhC,EAAwC;AACtC,WAAO,WAAP,CAAmB,EAAnB,EAAuB,eAAvB;;AAEA,aAAS,eAAT,CAAyB,GAAzB,EAA8B,YAA9B,EAA4C;AAC1C,UAAG,GAAH,EAAQ;AACN,cAAM,GAAN;AACA,eAAO,IAAP,CAAY,OAAZ,EAAqB,GAArB;AACA,eAAO,GAAP;AACA;AACD;AACD,UAAG,QAAQ,eAAX,EAA4B;AAC1B,0BAAkB,oBAAlB;AACD,OAFD,MAEO;AACL,YAAG,OAAO,QAAP,IAAmB,GAAtB,EAA2B;AACzB,gBAAM,qHAAN;AACD;AACD;AACD;;AAED,eAAS,oBAAT,CAA8B,GAA9B,EAAmC;AACjC,YAAG,GAAH,EAAQ;AACN,iBAAO,IAAP,CAAY,OAAZ,EAAqB,GAArB;AACA,iBAAO,GAAP;AACD,SAHD,MAGO;AACL;AACD;AACF;;AAED,eAAS,iBAAT,CAA2B,EAA3B,EAA+B;AAC7B,kBAAU,IAAV,CAAe,QAAQ,WAAvB,EAAoC,OAAO,OAAP,CAAe,eAAf,CAA+B,EAAnE,EACI,OAAO,QADX,EACqB,YADrB,EACmC,OAAO,SAD1C,EACqD,EADrD;AAED;;AAED,eAAS,yBAAT,GAAqC;AACnC,YAAM,SAAS,eAAe,OAAO,SAAtB,CAAf;AACA,YAAM,8BAA8B,OAAO,OAAP,CAAe,YAAf,EAA6B,SAA7B,EAAwC,SAAxC,EAAmD,KAAK,iBAAxD,CAApC;AACA,YAAM,6BAA6B,OAAO,OAAP,CAAe,OAAO,WAAtB,EAAmC,SAAnC,EAA8C,SAA9C,EAAyD,KAAK,iBAA9D,CAAnC;AACA,eAAO,KAAP,CAAa,kBAAb,EAAiC;AAC/B,wBAAc,2BADiB;AAE/B,uBAAa;AAFkB,SAAjC;AAIA,eAAO,aAAP,CAAqB,YAArB;AACD;AACF;AACF;AACF,CAhDD;;AAkDA,SAAS,cAAT,CAAwB,cAAxB,EAAwC;AACtC,MAAI,MAAM,8BAAV;AACA,MAAI,eAAe,eAAe,QAAf,CAAwB,QAAxB,CAAnB;AACA,MAAM,gBAAgB,EAAtB;AACA,SAAM,aAAa,MAAb,GAAsB,CAA5B,EAA+B;AAC7B,WAAO,aAAa,SAAb,CAAuB,CAAvB,EAA0B,aAA1B,IAA2C,IAAlD;AACA,mBAAe,aAAa,SAAb,CAAuB,aAAvB,CAAf;AACD;AACD,SAAO,4BAAP;AACA,SAAO,KAAK,eAAL,CAAqB,GAArB,EAA0B,MAA1B,CAAP;AACD","file":"client/encrypt.js","sourcesContent":["'use strict';\n\nconst crypto = require('crypto');\nconst yggserver = require('yggdrasil').server({});\nconst ursa=require(\"../ursa\");\nconst debug = require('debug')('minecraft-protocol');\n\nmodule.exports = function(client, options) {\n  client.once('encryption_begin', onEncryptionKeyRequest);\n\n  function onEncryptionKeyRequest(packet) {\n    crypto.randomBytes(16, gotSharedSecret);\n\n    function gotSharedSecret(err, sharedSecret) {\n      if(err) {\n        debug(err);\n        client.emit('error', err);\n        client.end();\n        return;\n      }\n      if(options.haveCredentials) {\n        joinServerRequest(onJoinServerResponse);\n      } else {\n        if(packet.serverId != '-') {\n          debug('This server appears to be an online server and you are providing no password, the authentication will probably fail');\n        }\n        sendEncryptionKeyResponse();\n      }\n\n      function onJoinServerResponse(err) {\n        if(err) {\n          client.emit('error', err);\n          client.end();\n        } else {\n          sendEncryptionKeyResponse();\n        }\n      }\n\n      function joinServerRequest(cb) {\n        yggserver.join(options.accessToken, client.session.selectedProfile.id,\n            packet.serverId, sharedSecret, packet.publicKey, cb);\n      }\n\n      function sendEncryptionKeyResponse() {\n        const pubKey = mcPubKeyToURsa(packet.publicKey);\n        const encryptedSharedSecretBuffer = pubKey.encrypt(sharedSecret, undefined, undefined, ursa.RSA_PKCS1_PADDING);\n        const encryptedVerifyTokenBuffer = pubKey.encrypt(packet.verifyToken, undefined, undefined, ursa.RSA_PKCS1_PADDING);\n        client.write('encryption_begin', {\n          sharedSecret: encryptedSharedSecretBuffer,\n          verifyToken: encryptedVerifyTokenBuffer\n        });\n        client.setEncryption(sharedSecret);\n      }\n    }\n  }\n};\n\nfunction mcPubKeyToURsa(mcPubKeyBuffer) {\n  let pem = \"-----BEGIN PUBLIC KEY-----\\n\";\n  let base64PubKey = mcPubKeyBuffer.toString('base64');\n  const maxLineLength = 65;\n  while(base64PubKey.length > 0) {\n    pem += base64PubKey.substring(0, maxLineLength) + \"\\n\";\n    base64PubKey = base64PubKey.substring(maxLineLength);\n  }\n  pem += \"-----END PUBLIC KEY-----\\n\";\n  return ursa.createPublicKey(pem, 'utf8');\n}\n"],"sourceRoot":"/source/"}