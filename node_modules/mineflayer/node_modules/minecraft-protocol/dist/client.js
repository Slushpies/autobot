'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var EventEmitter = require('events').EventEmitter;
var debug = require('debug')('minecraft-protocol');
var compression = require('./transforms/compression');
var framing = require('./transforms/framing');
var crypto = require('crypto');
var states = require("./states");

var createSerializer = require("./transforms/serializer").createSerializer;
var createDeserializer = require("./transforms/serializer").createDeserializer;

var Client = function (_EventEmitter) {
  _inherits(Client, _EventEmitter);

  function Client(isServer, version, customPackets) {
    _classCallCheck(this, Client);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(Client).call(this));

    _this.customPackets = customPackets;
    _this.version = version;
    _this.isServer = !!isServer;
    _this.splitter = framing.createSplitter();
    _this.setSerializer(states.HANDSHAKING);
    _this.packetsToParse = {};
    _this.serializer;
    _this.compressor = null;
    _this.framer = framing.createFramer();
    _this.cipher = null;
    _this.decipher = null;
    _this.decompressor = null;
    _this.deserializer;
    _this.isServer;
    _this.protocolState = states.HANDSHAKING;
    _this.ended = true;
    _this.latency = 0;

    _this.on('newListener', function (event, listener) {
      var direction = this.isServer ? 'toServer' : 'toClient';
      if (typeof this.packetsToParse[event] === "undefined") this.packetsToParse[event] = 1;else this.packetsToParse[event] += 1;
    });
    _this.on('removeListener', function (event, listener) {
      var direction = this.isServer ? 'toServer' : 'toClient';
      this.packetsToParse[event] -= 1;
    });
    return _this;
  }

  _createClass(Client, [{
    key: 'setSerializer',
    value: function setSerializer(state) {
      var _this2 = this;

      this.serializer = createSerializer({ isServer: this.isServer, version: this.version, state: state, customPackets: this.customPackets });
      this.deserializer = createDeserializer({ isServer: this.isServer, version: this.version, state: state, packetsToParse: this.packetsToParse, customPackets: this.customPackets });

      this.splitter.recognizeLegacyPing = state === states.HANDSHAKING;

      this.serializer.on('error', function (e) {
        var parts = void 0;
        if (e.field) {
          parts = e.field.split(".");
          parts.shift();
        } else parts = [];
        var serializerDirection = !_this2.isServer ? 'toServer' : 'toClient';
        e.field = [_this2.protocolState, serializerDirection].concat(parts).join(".");
        e.message = 'Serialization error for ' + e.field + ' : ' + e.message;
        if (!_this2.compressor) _this2.serializer.pipe(_this2.framer);else _this2.serializer.pipe(_this2.compressor);
        _this2.emit('error', e);
      });

      this.deserializer.on('error', function (e) {
        var parts = void 0;
        if (e.field) {
          parts = e.field.split(".");
          parts.shift();
        } else parts = [];
        var deserializerDirection = _this2.isServer ? 'toServer' : 'toClient';
        e.field = [_this2.protocolState, deserializerDirection].concat(parts).join(".");
        e.message = 'Deserialization error for ' + e.field + ' : ' + e.message;
        if (!_this2.compressor) _this2.splitter.pipe(_this2.deserializer);else _this2.decompressor.pipe(_this2.deserializer);
        _this2.emit('error', e);
      });

      this.deserializer.on('data', function (parsed) {
        parsed.metadata.name = parsed.data.name;
        parsed.data = parsed.data.params;
        parsed.metadata.state = state;
        debug("read packet " + state + "." + parsed.metadata.name);
        debug(parsed.data);
        _this2.emit('packet', parsed.data, parsed.metadata);
        _this2.emit(parsed.metadata.name, parsed.data, parsed.metadata);
        _this2.emit('raw.' + parsed.metadata.name, parsed.buffer, parsed.metadata);
        _this2.emit('raw', parsed.buffer, parsed.metadata);
      });
    }
  }, {
    key: 'setSocket',
    value: function setSocket(socket) {
      var _this3 = this;

      this.ended = false;

      // TODO : A lot of other things needs to be done.
      var endSocket = function endSocket() {
        if (_this3.ended) return;
        _this3.ended = true;
        _this3.socket.removeListener('close', endSocket);
        _this3.socket.removeListener('end', endSocket);
        _this3.socket.removeListener('timeout', endSocket);
        _this3.emit('end', _this3._endReason);
      };

      var onFatalError = function onFatalError(err) {
        _this3.emit('error', err);
        endSocket();
      };

      var onError = function onError(err) {
        return _this3.emit('error', err);
      };

      this.socket = socket;

      if (this.socket.setNoDelay) this.socket.setNoDelay(true);

      this.socket.on('connect', function () {
        return _this3.emit('connect');
      });

      this.socket.on('error', onFatalError);
      this.socket.on('close', endSocket);
      this.socket.on('end', endSocket);
      this.socket.on('timeout', endSocket);
      this.framer.on('error', onError);
      this.splitter.on('error', onError);

      this.socket.pipe(this.splitter).pipe(this.deserializer);
      this.serializer.pipe(this.framer).pipe(this.socket);
    }
  }, {
    key: 'end',
    value: function end(reason) {
      this._endReason = reason;
      if (this.cipher) this.cipher.unpipe();
      if (this.framer) this.framer.unpipe();
      if (this.socket) this.socket.end();
    }
  }, {
    key: 'setEncryption',
    value: function setEncryption(sharedSecret) {
      var _this4 = this;

      if (this.cipher != null) throw new Error("Set encryption twice !");
      this.cipher = crypto.createCipheriv('aes-128-cfb8', sharedSecret, sharedSecret);
      this.cipher.on('error', function (err) {
        return _this4.emit('error', err);
      });
      this.framer.unpipe(this.socket);
      this.framer.pipe(this.cipher).pipe(this.socket);
      this.decipher = crypto.createDecipheriv('aes-128-cfb8', sharedSecret, sharedSecret);
      this.decipher.on('error', function (err) {
        return _this4.emit('error', err);
      });
      this.socket.unpipe(this.splitter);
      this.socket.pipe(this.decipher).pipe(this.splitter);
    }
  }, {
    key: 'setCompressionThreshold',
    value: function setCompressionThreshold(threshold) {
      var _this5 = this;

      if (this.compressor == null) {
        this.compressor = compression.createCompressor(threshold);
        this.compressor.on('error', function (err) {
          return _this5.emit('error', err);
        });
        this.serializer.unpipe(this.framer);
        this.serializer.pipe(this.compressor).pipe(this.framer);
        this.decompressor = compression.createDecompressor(threshold);
        this.decompressor.on('error', function (err) {
          return _this5.emit('error', err);
        });
        this.splitter.unpipe(this.deserializer);
        this.splitter.pipe(this.decompressor).pipe(this.deserializer);
      } else {
        this.decompressor.threshold = threshold;
        this.compressor.threshold = threshold;
      }
    }
  }, {
    key: 'write',
    value: function write(name, params) {
      if (this.ended) return;
      debug("writing packet " + this.state + "." + name);
      debug(params);
      this.serializer.write({ name: name, params: params });
    }
  }, {
    key: 'writeRaw',
    value: function writeRaw(buffer) {
      if (this.ended) return;
      if (this.compressor === null) this.framer.write(buffer);else this.compressor.write(buffer);
    }

    // TCP/IP-specific (not generic Stream) method for backwards-compatibility

  }, {
    key: 'connect',
    value: function connect(port, host) {
      var options = { port: port, host: host };
      if (!this.options) this.options = options;
      require('./client/tcp_dns')(this, options);
      options.connect(this);
    }
  }, {
    key: 'state',
    get: function get() {
      return this.protocolState;
    },
    set: function set(newProperty) {
      var oldProperty = this.protocolState;
      this.protocolState = newProperty;

      if (!this.compressor) {
        this.serializer.unpipe(this.framer);
        this.splitter.unpipe(this.deserializer);
      } else {
        this.serializer.unpipe(this.compressor);
        this.decompressor.unpipe(this.deserializer);
      }

      this.serializer.removeAllListeners();
      this.deserializer.removeAllListeners();
      this.setSerializer(this.protocolState);

      if (!this.compressor) {
        this.serializer.pipe(this.framer);
        this.splitter.pipe(this.deserializer);
      } else {
        this.serializer.pipe(this.compressor);
        this.decompressor.pipe(this.deserializer);
      }

      this.emit('state', newProperty, oldProperty);
    }
  }, {
    key: 'compressionThreshold',
    get: function get() {
      return this.compressor == null ? -2 : this.compressor.compressionThreshold;
    },
    set: function set(threshold) {
      this.setCompressionThreshold(threshold);
    }
  }]);

  return Client;
}(EventEmitter);

module.exports = Client;
//# sourceMappingURL=maps/client.js.map
